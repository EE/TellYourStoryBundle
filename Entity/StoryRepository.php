<?php

namespace EE\TYSBundle\Entity;

use Doctrine\Common\Annotations\AnnotationReader;
use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\Common\Collections\Criteria;
use Doctrine\DBAL\DriverManager;
use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\NativeQuery;
use Doctrine\ORM\Query;
use Doctrine\ORM\Query\ResultSetMapping;
use Doctrine\ORM\QueryBuilder;

/**
 * StoryRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class StoryRepository extends EntityRepository
{

    /**
     * @param QueryBuilder $qb
     * @param User $user
     * @param string $alias
     * @return QueryBuilder
     */
    private function addOwnedOrPublished(QueryBuilder $qb, User $user, $alias = 's')
    {
        return $qb
            ->where($alias . '.published = :published')
            ->orWhere($alias . '.createdBy = :user')
            ->setParameter(':user', $user->getId())
            ->setParameter(':published', true);
    }

    /**
     * @param QueryBuilder $qb
     * @param string $alias
     * @return QueryBuilder
     */
    private function addPublished(QueryBuilder $qb, $alias = 's')
    {
        return $qb
            ->andWhere($alias . '.published = :published')
            ->setParameter(':published', true);
    }

    /**
     * Adds "story not in collections" query part safely.
     * If no stories are included in collections passing empty array to the expression ends up in a server error
     *
     * @param QueryBuilder $qb
     * @return QueryBuilder
     */
    private function addNotInCollections(QueryBuilder $qb)
    {
        $notInCollections = $this->tmpGetStoriesInCollections();
        return count($notInCollections) === 0 ? $qb : $qb->andWhere($qb->expr()->notIn('s.id', $notInCollections));
    }

    /**
     * @param string $alias
     * @param User $user
     * @return \Doctrine\ORM\QueryBuilder
     */
    private function getOwnedOrPublishedQb(User $user, $alias = 's')
    {
        return $this->addOwnedOrPublished($this->createQueryBuilder($alias), $user);
    }

    /**
     * @param string $alias
     * @return QueryBuilder
     */
    private function getPublishedQb($alias = 's')
    {
        return $this->addPublished($this->createQueryBuilder($alias));
    }

    /**
     * @param string $alias
     * @param $id
     * @return \Doctrine\ORM\QueryBuilder
     */
    private function getByCollectionQb($id, $alias = 's')
    {
        return $this->createQueryBuilder($alias)
            ->join($alias . '.storyCollections', 'sc')
            ->where('sc.id = :storyCollectionId')
            ->setParameter('storyCollectionId', $id);
    }

    /**
     * Returns published stories
     *
     * @return Query
     */
    public function getPublishedQuery()
    {
        return $this->getPublishedQb()->getQuery();
    }

    /**
     * Returns stories that are both published and owned by user
     *
     * @param User $user
     *
     * @return Query
     */
    public function getOwnedOrPublishedQuery(User $user)
    {
        return $this->getOwnedOrPublishedQb($user)->getQuery();
    }

    /**
     * I found no better way to extract Stories that are connected many-to-many to StoryCollection
     * this method depends on a fact that joinTable is explicitly given in the entity class.
     * @todo: find better way
     * @return array
     * @throws \Doctrine\DBAL\DBALException
     */
    private function tmpGetStoriesInCollections()
    {
        $reader = new AnnotationReader();
        $joinTable = $reader
            ->getPropertyAnnotation(
                new \ReflectionProperty('EE\TYSBundle\Entity\Story', 'storyCollections'),
                'Doctrine\ORM\Mapping\JoinTable'
            );

        $storiesInCollectionsStatement = $this->_em
            ->getConnection()
            ->prepare('SELECT DISTINCT story_id FROM ' . $joinTable->name);

        $storiesInCollectionsStatement->execute();

        $storiesInCollections = array();
        foreach ($storiesInCollectionsStatement->fetchAll() as $v) {
            $storiesInCollections[] = $v['story_id'];
        }

        return $storiesInCollections;
    }

    /**
     * @return array
     */
    public function findAllNotInCollections()
    {
        return $this->addNotInCollections($this->createQueryBuilder('s'), 's')->getQuery()->execute();
    }

    /**
     * @return array
     */
    public function findPublishedNotInCollections()
    {
        return $this->addNotInCollections($this->getPublishedQb('s'), 's')->getQuery()->execute();
    }

    /**
     * @param User $user
     * @return mixed
     */
    public function findOwnedOrPublishedNotInCollections(User $user)
    {
        return $this->addNotInCollections($this->getOwnedOrPublishedQb($user, 's'), 's')->getQuery()->execute();
    }

    /**
     * @param $id
     * @return mixed
     */
    public function findAllByCollection($id)
    {
        return $this->getByCollectionQb($id)->getQuery()->execute();
    }

    /**
     * @param $id
     * @return mixed
     */
    public function findPublishedByCollection($id)
    {
        return $this->addPublished($this->getByCollectionQb($id, 'k'))->getQuery()->execute();
    }

    /**
     * @param $id
     * @param User $user
     * @return mixed
     */
    public function findOwnedOrPublishedByCollection($id, User $user)
    {
        return $this->addOwnedOrPublished($this->getByCollectionQb($id, 'k'), $user)->getQuery()->execute();
    }
}
